
#ifndef TRACE_MODEL_HPP_VP_2006_03_20
#define TRACE_MODEL_HPP_VP_2006_03_20

class Trace;
class Event_model;
class State_model;
class Group_model;

#include <memory>

/** Абстракное представление трассы для визуализатора. 

    Этот абстрактный класс описывает то, что должно быть показано на зкране (линии жизни,
    события, состояние), и предоставляет интерфейсы для навигации по командам пользователя. 
    Метод определения показываемых данных определяется унаследованными классами, данный
    класс не предполагает ничего конкретного.

    Абсолютно весь доступ к трассе внутри Vis3 делается через этот интерфейс, включая все пользовальские
    интструменты.

    Все классы-потомки должны быть "легкими", объем используемой памяти на каждый экземпляров
    должен быть минимальным, и копирование/навигация должны быть быстрыми операциями. Это означает,
    что при использовании сложных структур данных для представления трассы экземпляры классов-потомков
    должы ссылаться на информацию о трассе, содержа внутри себя только выбранные времена/фильтры.

    Предоставляемые интерфейсы не дают возможности изменить объект. Все методы навигации создают новый 
    экземпляр. Это, в сочетании с требованием "легкости" объектов, позволяет сохранять объекты, чтобы
    потом к ним можно быть быстро вернуться. Это полезно, например, для операции "back".

    Навигация выполняется по трем осям.

    Первая ось -- положение в структуре компонент. Предполагается, что есть конечное число позиций
    в структуре компонетнов. Для каждой позиции есть набор потенциально видимых линий жизни, событий
    и состояний. Набор таких позиций определяется конкретным экземпляром конкретной реализации
    интерфейса Trace_model.

    Между позициями возможны переходы двух типов
    - Переход "наверх"
    - "Раскрытие" одной из линий жизни в входом в него
    Для каждого положения возможность выполнения этих переходов определяет конкретная реализация 
    интерфейса Trace_model.

    Необходимо отметить, что "наверх" и "раскрытие" -- условные понятия, и не предпогалают древесную
    структуру. Возможен вариант, когда ни для какой позиции не определены переходы наверх и
    вниз, в этом случае вся навигация должна делаться проекто-специфичным способом. Более реальная ситуация --
    когда есть основное дерево компонентов, навигация по которому осуществляется с помощью переходов
    вверх и вниз, и отдельные "специальные" представления трассы, переход на которые использует
    проекто-специфичные механизмы.

    Вторая ось навигации -- фильтры линий жизни, событий и состояний. Если положение в структуре
    компонент определяет потенциальный набор этих объектов, то дополнительная фильтрация определяет
    реально видимый набор.

    Третья ось навигации -- это минимальное и максимальное показываемое время. Речь идет именно о
    показываемом времени -- левой и правой границе временной диаграмме. Объекты, возвращаемые Trace_model,
    могут выходить за этот диапазон, что особенно актуально для "протяженных" объектыов
    (состояния и групповые события). Можно считать, что все объекты рисуются на бесконечной плоскости, 
    после чего плоскость обрезается заданному диапазону времени. 

    Навигация по всем трем осям выполняется с помощью вызовом методов класса Trace_model, которые
    создают новый объект класс Trace_model с новым представлением трассы. Например, для раскрытия
    одной из линий жизни вызывается метод enter_component с номером линии жазни, для фильтации части
    компонентов вызывается метод filters_components c булевой маской. Для каждой оси навигации
    имеются методы которые возвращаются "обратно" -- на верхний уровень иерархии, к нефильтрованному
    состоянию, и к максимальному диапазону времени.
*/
class Trace_model 
{
public:
    /** Returns the name of the parent component,
        or empty if there's no parent. */
    virtual std::string parent_name() const = 0;

    /** Возвращает список имен всех видимых компонент. 
    
        Имена компонент должны быть уникальными, так как неуникальные имена
        могут запутать пользователя. */
    virtual const std::vector<QString>& component_names() const = 0;

    /** Возвращает true если компонет i имеет "детей" и в него можно войдти.
        @sa enter_component. */
    virtual bool has_children(int i) const = 0;

    /** Возвращает минимальное время, которое должно показываться на временной диаграмме. */
    virtual unsigned min_time() const = 0;

    /** Возвращает максимальное время, которое должно показываться на временной диаграмме. */
    virtual unsigned max_time() const = 0;

    /** Переводит внутренние указатели событий, состояний и групповых событий
       на минимальное время. */
    virtual void rewind() = 0;

    /** Возвращает следующее событие с трассе и увеличивает внутренний указатель
        событий. Если больше собитый нет, возвращает нулевой указатель. */
    virtual std::auto_ptr<Event_model> next_event() = 0;

    /** Возвращает следующее состояние в трассе и увеличивает внутренний указатель
    событий. Если больше собитый нет, возвращает нулевой указатель. */
    virtual std::auto_ptr<State_model> next_state() = 0;

    /** Возвращает следующее состояние в трассе и увеличивает внутренний указатель
    событий. Если больше собитый нет, возвращает нулевой указатель. */
    virtual std::auto_ptr<Group_model> next_group() = 0;    

    /** Возвращает объект Trace_model соответствующий "начальному" положению
    в структуре компонетов, максимальному возможному диапазону времен и
    не имеющий никаких фильтров. */
    virtual Trace_model* root() = 0;

    /** Возвращает Trace_model, показывающий i-й компонент this, в "раскрытом"
    виде. */
    virtual Trace_model* enter_component(int i) = 0;

    /** Возврашает новый объект Trace_model с указанным диапазоном времен. */
    virtual Trace_model* set_range(unsigned min, unsigned max) = 0;

    /** Создает новый объект, который содержит только те компоненты, для
       которых в массиве allow стоит true. Размер массива должен быть равен
       component_names().size(). */
    virtual Trace_model* filter_components(const QVector<bool>& allow) = 0;

    /** Возврашает "непрозрачный" строковый идентификатор положения в структуре компонетов.

        Идентификатор может использоваться только для сопоставления каких-либо дополнительных
        данных. Структура идентификатора не специфицирована.
    */
    QString component_tree_location() const;

    /** Возвращает объект Trace_model, который отличается от this только отсутсвием каких-либо
        фильтров по компонентам/событиям/состояниям. */
    virtual Trace_model* unfiltered() = 0;

    /** Возвращает список типов событий. Все типы должны быть уникальными. */
    virtual std::vector<QString> event_kinds() = 0;

    /** Создает новый объект, который содержит события только тех типов, для
        которых в массиве allow стоит true. Размер массива должен быть равен
        event_kinds().size(). */
    virtual Trace_model* filter_events(const QVector<bool>& allow) = 0;

    /** Сохраняет текущее состояние в строку и возвращает его. Структура строки не
       определена. */
    virtual QString save() const = 0;

    /** По строке, ранее возвращенной функцией save, пытается восстановить 
       состояние. Функция не обязательно что-то делает, если реальная данные трассы 
       слишком отличаются от данных трассы в момент вызова save, функция может ничего
       не делать.

       Основное предназначение -- для восстановления состояния графического интерфейса
       при последующих запусках. */
    virtual void restore(const QString& s) = 0;

    virtual ~Trace_model() {}

};


#endif
